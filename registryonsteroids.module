<?php

/**
 * @file
 * registryonsteroids.module
 */

global $conf;

// Auto-rebuild the theme registry.
if (variable_get('registryonsteroids_rebuild_registry', FALSE) && !defined('MAINTENANCE_MODE')) {
  // Rebuild .info data.
  system_rebuild_theme_data();
  // Rebuild theme registry.
  drupal_theme_rebuild();
}

$conf['theme_debug'] = variable_get('registryonsteroids_theme_debug', FALSE);

/**
 * Implements hook_menu().
 */
function registryonsteroids_menu() {
  return array(
    'admin/config/development/registryonsteroids' => array(
      'title' => 'Registry On Steroïds',
      'description' => 'Registry On Steroïds configuration',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('_registryonsteroids_admin_settings'),
      'access arguments' => array(
        'administer site',
      ),
      'file' => 'registryonsteroids.admin.inc',
    ),
  );
}

/**
 * @file
 * Main module file.
 */

/**
 * Implements hook_module_implements_alter().
 */
function registryonsteroids_module_implements_alter(array &$implementations, $hook) {
  if ('theme_registry_alter' === $hook) {
    $group = $implementations['registryonsteroids'];
    unset($implementations['registryonsteroids']);
    $implementations['registryonsteroids'] = $group;
  }
}

/**
 * Implements hook_theme_registry_alter().
 */
function registryonsteroids_theme_registry_alter(array &$registry) {
  // Get all themes.
  $all_themes = list_themes();

  // Compile an array of base themes object.
  $base_themes = array_reverse(
    _registryonsteroids_theme_get_ancestors(
      // @ŧodo This is likely the same as $GLOBALS['theme'].
      $all_themes[$GLOBALS['theme']]->name));

  // Extract the current theme.
  $theme = array_pop($base_themes);

  // Apply Registry On Steroids sauce.
  _theme_post_process_registry($registry, $base_themes, $theme);
}

/**
 * Registry post process mechanism.
 *
 * @param array[] $registry
 *   The registry.
 * @param object[] $base_themes
 *   The base themes.
 * @param object $theme
 *   The current theme.
 */
function _theme_post_process_registry(array &$registry, array $base_themes, $theme) {
  $prefixes_data = _registryonsteroids_theme_make_prefixes($base_themes, $theme);
  $themes = array_merge($prefixes_data['module'], $prefixes_data['theme_engine'], $prefixes_data['base_theme'], $prefixes_data['theme']);
  $grouped_functions = drupal_group_functions_by_prefix();

  // Reverse sort the registry.
  krsort($registry);

  // Iterate over each registered hook.
  foreach ($registry as $hook => &$info) {
    // The pattern to match.
    $pattern = isset($info['pattern']) ? $info['pattern'] : ($hook . '__');

    // Only process hooks that have not explicitly "turned off" patterns.
    if (empty($pattern)) {
      continue;
    }

    // Iterate over each themes objects.
    // This is in order: the theme engine, the base theme(s), the current theme.
    foreach ($themes as $theme_hook) {
      _registryonsteroids_theme_find_processors($grouped_functions, $registry, $info, $theme_hook, $hook);

      // Ensure "theme path" is set.
      $info += array(
        'theme path' => drupal_dirname($theme->filename),
      );

      // Remove this member so each hook is independent and doesn't depend or
      // inherit of it's parent hook.
      // This prevent many situations where the preprocess/process calls orders
      // are not triggered at all or in the right order.
      unset($info['base hook']);
    }

    _registryonsteroids_theme_add_processors($hook, $info, $prefixes_data);
  }

  // Registry optimization and includes fiddling.
  // This cannot be included in the previous loop as the previous loop
  // might create new members on the fly.
  foreach ($registry as $hook => &$info) {
    // Make sure the includes member of each hook is completed with its
    // parent hook.
    list($original_hook,) = explode('__', $hook);
    $info += array('includes' => array());
    $registry[$original_hook] += array('includes' => array());
    $info['includes'] = array_unique(
      array_merge(
        (array) $info['includes'],
        (array) $registry[$original_hook]['includes']
      )
    );

    // Optimize the registry.
    $info = array_filter($info);
  }

  // Sort the registry.
  ksort($registry);
}

/**
 * Find the processors callbacks.
 *
 * @param array $grouped_functions
 *   An array of grouped functions.
 * @param array $cache
 *   The registry.
 * @param array $info
 *   The current hook data.
 * @param string $theme
 *   The current theme name.
 * @param string $hook
 *   The current hook.
 */
function _registryonsteroids_theme_find_processors(array $grouped_functions, array &$cache, array &$info, $theme, $hook) {
  // The pattern to match.
  $pattern = isset($info['pattern']) ? $info['pattern'] : ($hook . '__');

  foreach (_registryonsteroids_theme_processors_phases() as $phase) {
    // Find functions matching the specific theme and phase prefix.
    $prefix = $theme . '_' . $phase;

    // Grep only the functions which are within the prefix group.
    list($first_prefix,) = explode('_', $prefix, 2);
    if (isset($grouped_functions[$first_prefix]) && ($matches = preg_grep(
        '/^' . $prefix . '_' . $pattern . '/',
        $grouped_functions[$first_prefix]
      ))) {
      foreach ($matches as $match) {
        // Determine the current theme implementation.
        $base_hook = drupal_substr($match, drupal_strlen($prefix) + 1);

        if (!isset($cache[$base_hook])) {
          $cache[$base_hook] = $info;
          $cache[$base_hook]['type'] = 'theme';
        }
      }
    }
  }
}

/**
 * Add the processors to the hook.
 *
 * @param string $hook
 *   The current hook.
 * @param array $info
 *   The current hook data.
 * @param array $prefixes_data
 *   The prefixes.
 */
function _registryonsteroids_theme_add_processors($hook, array &$info = array(), array $prefixes_data = array()) {
  $hooks_stack = drupal_get_hook_parents($hook);

  foreach (_registryonsteroids_theme_processors_phases() as $phase_key => $phase) {
    $callbacks = array();

    foreach ($prefixes_data as $prefixes) {
      foreach ($prefixes as $prefix) {
        $callbacks[] = $prefix . '_' . $phase;
        // This is the code that ensure preprocess/process inheritance.
        // TODO here detect how to set 'theme path'.
        array_map(
          function ($hook) use (&$callbacks, $phase, $prefix) {
            $callbacks[] = $prefix . '_' . $phase . '_' . $hook;
          },
          array_reverse($hooks_stack));
      }
    }

    // This is for dealing with modules implementing hook_theme_registry_alter.
    // By doing this, I make sure that no process callbacks that has been added
    // through this hook are lost.
    $info[$phase_key] = array_merge(
      $callbacks,
      array_diff($info[$phase_key], $callbacks)
    );

    // Ensure uniqueness of functions.
    $info[$phase_key] = array_unique($info[$phase_key]);

    // Filter out functions that does not exist.
    $info[$phase_key] = array_values(array_filter($info[$phase_key], '\function_exists'));

    // Sadly we remove preprocess and process for hooks that provides
    // a theme function. (like the date module with date_display_single).
    // We could have this in but some modules badly implementing
    // attributes handling would fail.
    if (isset($info['function'])) {
      $info[$phase_key] = array_filter(
        $info[$phase_key],
        function ($function) use ($phase, $hook) {
          return FALSE !== strpos($function, $phase . '_' . $hook);
        });
    }
  }
}

/**
 * Get processors name and machine name.
 *
 * Processor functions work in two distinct phases with the process
 * functions always being executed after the preprocess functions.
 *
 * @return array
 *   The processors names and machine names.
 */
function _registryonsteroids_theme_processors_phases() {
  return array(
    'preprocess functions' => 'preprocess',
    'process functions'    => 'process',
  );
}

/**
 * Compile a list of prefixes.
 *
 * The order of this is very important.
 *
 * @param object[] $base_themes
 *   The array of base themes.
 * @param object $theme
 *   The current theme.
 *
 * @see https://api.drupal.org/api/drupal/includes!theme.inc/function/theme/7.x
 *
 * @return array
 *   The prefixes.
 */
function _registryonsteroids_theme_make_prefixes(array $base_themes, $theme) {
  return array(
    'template' => array(
      'template' => 'template',
    ),
    'module' => module_list(),
    'theme_engine' => array(
      $theme->engine => $theme->engine,
    ),
    'base_theme' => array_combine(
      array_keys($base_themes),
      array_keys($base_themes)
    ),
    'theme' => array(
      $theme->name => $theme->name,
    ),
  );
}

/**
 * Group all user functions by word before first underscore.
 *
 * @return array
 *   Functions grouped by the first prefix.
 */
function drupal_group_functions_by_prefix() {
  $functions = get_defined_functions();
  $grouped_functions = array();

  // Splitting user defined functions into groups by the first prefix.
  foreach ($functions['user'] as $function) {
    list($first_prefix,) = explode('_', $function, 2);
    $grouped_functions[$first_prefix][] = $function;
  }

  return $grouped_functions;
}

/**
 * Gets the parents of a hook.
 *
 * @param string $hook
 *   The hook, e.g. 'aaa__bbb__ccc'.
 *
 * @return string[]
 *   The parent hooks, e.g. ['aaa__bbb__ccc', 'aaa__bbb', 'aaa'].
 */
function drupal_get_hook_parents($hook) {
  $parents = array($hook);

  // @todo Combination of non-multibyte strrpos() and multibyte drupal_substr()?
  while ($pos = strrpos($hook, '__')) {
    // In theory, drupal_substr() can return FALSE. But not here. Promise.
    $parents[] = $hook = drupal_substr($hook, 0, $pos);
  }

  return $parents;
}

/**
 * Get the theme ancestors of a theme.
 *
 * @param string $theme_key
 *   Name of the theme to start with.
 *
 * @return object[]|false
 *   Hierarchy of base theme objects, with order as specified in $root_first, or
 *   FALSE, if the theme itself or any of its ancestors are missing.
 *   Format:
 *   [
 *     'THEMENAME' => $theme,
 *     'PARENT_NAME' => $parent_theme,
 *     [..]
 *     'ROOT_NAME' => $root_theme,
 *   ]
 */
function _registryonsteroids_theme_get_ancestors($theme_key) {
  /**
   * @var object[][] $hierarchies_objects
   *   Format:
   *   $['THEMENAME'] = [
   *     'THEMENAME' => $theme,
   *     'PARENT_NAME' => $parent_theme,
   *     [..]
   *     'ROOT_NAME' => $root_theme,
   *   ]
   */
  static $hierarchies_objects = array();

  return isset($hierarchies_objects[$theme_key])
    ? $hierarchies_objects[$theme_key]
    : $hierarchies_objects[$theme_key] = _registryonsteroids_theme_collect_ancestors(
      $theme_key,
      list_themes());
}

/**
 * Collect the theme ancestors of a theme.
 *
 * @param string $theme_key
 *   Name of the theme to start with.
 * @param object[] $known_themes
 *   The result of list_themes()
 *   This is passed as a parameter to make testing easier.
 *
 * @return object[]|false
 *   Hierarchy of base theme objects, starting with the theme itself.
 *   E.g. ['mytheme' => $my_theme, 'zen' => $zen]
 *   FALSE, if the theme itself or any of its ancestors is not in $known_themes.
 */
function _registryonsteroids_theme_collect_ancestors($theme_key, array $known_themes) {

  if (!isset($known_themes[$theme_key]->info)) {
    // The theme does not exist.
    return FALSE;
  }

  $hierarchy_objects = array();

  while (TRUE) {
    if (!isset($known_themes[$theme_key]->info)) {
      // The hierarchy contains an unknown theme name.
      return FALSE;
    }
    $hierarchy_objects[$theme_key] = $theme = $known_themes[$theme_key];
    $info = $theme->info;
    if (empty($info['base theme'])) {
      // Bottom of the hierarchy is here.
      break;
    }
    $theme_key = $info['base theme'];
  }

  return $hierarchy_objects;
}
